---
title:  "[C++] SWEA 5644 : [모의 SW 역량테스트] 무선 충전"
excerpt: "DFS"
categories: Code
tags: 
- SWEA
- 5644번
- 무선 충전
- 코딩테스트
author_profile: true
---

SWEA 5644번 문제를 풀어보았다.

![image-20210131161839791](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210131161839791.png)

<br>

# 1. 문제 설명

![image](https://user-images.githubusercontent.com/37764581/106377336-ca6e1180-63df-11eb-8384-4e577aa5b0ab.png)

<br>

![image](https://user-images.githubusercontent.com/37764581/106377450-6ac43600-63e0-11eb-879e-d8874f467d7a.png)

+ NxN의 Processor에 core가 박혀있고 가장자리에는 전원이 흐른다.
  + core에 **직선의 전선**을 이용해 전원이 연결되게 해야한다. (단, 전선끼리 교차되면 X)
  + **모든 core**가 연결되어야 하는 것은 아님.
+ **최대한 많은 Core**에 전원을 연결했을 경우, **전선의 길이가 최소**가 되는 때의 전선 길이를 출력하여라.

<br>

# 2. 문제 풀이

## 2.1 사용 변수

```cpp
int proc[12][12] = { 0, };
info core[12] = { {0,0}, };

void conq(int idx, int d)
bool check(int idx, int d)
```

+ `proc[][]`
  + processor의 칸에 전선 or core가 있는지 표시하는 용도
  + core는 1, 전선은 2로 표시
+ `core[]`
  + core가 어디에 존재하는지 {y,x}로 좌표를 저장하여 후에 core의 위치에 접근을 빠르게 함.
+ `bool check(int idx, int d)`
  + `idx` : 현재 체크하려는 core, `d` : core를 기준으로 체크하려는 방향
+ `void conq(int idx, int d)`
  + `idx` : 현재 전원과 연결하려는 core, `d` : core를 기준으로 전원과 연결하려는 방향

<br>

## 2.2 Solution

+ 연결할 수 있는 core의 조합을 dfs를 이용하여 확인한다.
+ 한 core에 대하여 상, 하, 좌, 우, X 의 선택권이 있다.
  + X는 연결하지 않고 포기하는 방법
+ `max_connected`를 이용하여 최대로 연결 가능했던 core의 개수를 저장
+ `min_wire`을 이용하여 `max_connected`만큼 연결했을 때 사용하였던 최소의 전선 길이를 저장

> ⭐추가한 코드⭐
>
> dfs를 진행할 때마다 현재 남은 core를 모두 연결하더라도  `max_connected`보다 작은지 확인하여 중단시켜주면 시간을 훨씬 절약할 수 있다.
> {: .notice--info}
> 
>`max_connected`와 같을 경우에는 더 적은 wire을 사용할 수 있으므로 그대로 진행시킨다.





<br>

## 2.3 전체 코드

```cpp
#include <iostream>
#include <utility>
#include <queue>
#include <algorithm>
 
using namespace std;
 
int M = 0; //이동 시간
int A = 0; //발전기 개수
int Amob[100] = { 0, }; //A의 이동경로 (0,1,2,3,4 : x, 상, 우, 하, 좌)
int Bmob[100] = { 0, }; //B의 이동경로
int AP[8][4] = { 0, }; //발전기 정보
 
pair<int, int> Acur=make_pair(1,1);
pair<int, int> Bcur = make_pair(10, 10);
int result = 0;
 
int abs(int a, int b) {
    return a > b ? a - b : b - a;
}
 
void dist() {
    vector<pair<int, int> > Acandi, Bcandi;
    for (int i = 0; i < A; i++) {
        if (abs(AP[i][0], Acur.first) + abs(AP[i][1], Acur.second) <= AP[i][2])
            Acandi.push_back(make_pair(AP[i][3],i));
        if (abs(AP[i][0], Bcur.first) + abs(AP[i][1], Bcur.second) <= AP[i][2])
            Bcandi.push_back(make_pair(AP[i][3], i));
    }
 
    if (Acandi.size() > 1)
        sort(Acandi.begin(), Acandi.end(), greater<pair<int, int> >());
    if (Bcandi.size() > 1)
        sort(Bcandi.begin(), Bcandi.end(), greater<pair<int, int> >());
 
    if (Acandi.size() == 0 || Bcandi.size() == 0) {
        if (Acandi.size() != 0) result += Acandi[0].first;
        if (Bcandi.size() != 0) result += Bcandi[0].first;
    }
    else if(Acandi.front() != Bcandi.front()) {
        result += Acandi[0].first;
        result += Bcandi[0].first;
    }
    else if (Acandi[0] == Bcandi[0]) {
        if (Acandi.size() == 1 && Bcandi.size() == 1)
            result += Acandi[0].first;
        else if (Acandi.size() > 1 && Bcandi.size() == 1) {
            result += Bcandi[0].first;
            result += Acandi[1].first;
        }
        else if (Acandi.size() == 1 && Bcandi.size() > 1) {
            result += Acandi[0].first;
            result += Bcandi[1].first;
        }
        else {
            //뭐가 더 큰지 판별
            result += Acandi[0].first;
            result += (Acandi[1].first > Bcandi[1].first ? Acandi[1].first : Bcandi[1].first);
        }
    }
     
}
 
/*D = |XA – XB| + |YA – YB|*/
void func() {
    dist();
 
    for (int i = 0; i < M; i++) {
        switch (Amob[i]) {
        case 0:
            break;
        case 1: //상
            Acur.second--;
            break;
        case 2: //우
            Acur.first++;
            break;
        case 3: //하
            Acur.second++;
            break;
        case 4: //좌
            Acur.first--;
            break;
        }
 
        switch (Bmob[i]) {
        case 0:
            break;
        case 1: //상
            Bcur.second--;
            break;
        case 2: //우
            Bcur.first++;
            break;
        case 3: //하
            Bcur.second++;
            break;
        case 4: //좌
            Bcur.first--;
            break;
        }
 
        dist();
    }
}
 
int main(int argc, char** argv)
{
    int test_case;
    int T;
 
    cin >> T;
     
    for (test_case = 1; test_case <= T; ++test_case)
    {
        cin >> M;
        cin >> A;
 
        for (int i = 0; i < M; i++)
            cin >> Amob[i];
        for (int i = 0; i < M; i++)
            cin >> Bmob[i];
 
        for (int i = 0; i < A; i++) {
            for (int j = 0; j < 4; j++)
                cin >> AP[i][j];
        }
 
 
        result = 0;
        Acur = make_pair(1, 1);
        Bcur = make_pair(10, 10);
        func();
 
        cout << "#" << test_case << " " << result << endl;
 
    }
    return 0;//정상종료시 반드시 0을 리턴해야합니다.
}
```
<br>

# 3. Review

상하좌우마다 다른 조건을 줘야해서 코드가 많이 늘어났다.

<br>

# 4. 실패한 접근 방법

없음.

